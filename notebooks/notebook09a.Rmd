---
title: "Notebook 09A"
output: html_document
---

```{r, include=FALSE}
library(tidyverse)
library(ggrepel)
library(smodels)

theme_set(theme_minimal())
options(pillar.min_character_chars = 15)
```

## Instructions

This notebook includes several tasks to practice and extend your knowledge of
the material covered within the chapter. For the most part, every notebook with
a name ended in "A" will work with a collection of data about cities and their
population. The questions tend to be relatively contained; the focus is
primarily on writing code to perform a specific task. For this purpose there
will usually be an empty code block for you to put your code. There are also
questions requiring a short response, prompted by the phrase "**Answer:**".
Your answers to these can be write directly in this notebook. Occasionally
new functions or concepts will be shown within each notebook.

Notebooks ending in letters other than "A" more often include new datasets and
open-ended prompts for using the data skills covered in the chapters to address
a wide range of questions. It is suggested to start with the "A" notebook for
each chapter and then trying to work through at least one additional data
project notebook.

When you are done with your code, hitting the *knit* button in the toolbar will
produce an HTML webpage with all of your results. Note that the first time you
run the knit function may require installing some packages. Knitting your code
is a good way to help check that you have written all of the code correctly and
have not accidentally modified anything as you worked through the notebook.

Two important pieces of advice when working through the notebooks:

- It is a best practice to close RStudio everytime that you finish with a
notebook and before you start working on another dataset. This starts each
notebook from scratch and does not risk accidentally using variables created in
one notebook within the scope of another.

- Notice that the notebook file does not automatically word-wrap the way you
may be used to in a word processor. Generally, you should manually hit enter to
start typing on a new line. I try to make sure that both my text and my code are
not very wide. Make sure to do the same with your code and responses. Also, make
sure that your notebook window is wide enough so that my text does not forceable
try to wrap. This is very hard to read and makes it much easier to work through
the notebook.

## Largest City and Köppen Datasets

In this notebook we will work with the largest cities dataset:

```{r, message=FALSE}
cities <- read_csv(file.path("..", "data", "largest_cities.csv"))
```

We will also load a dataset containing metadata about the Köppen climate
classification scores.

```{r, message=FALSE}
koppen <- read_csv(file.path("..", "data", "koppen_metadata.csv"))
koppen
```

We will use the techniques shown in Chapter 9 to combine these two data sources.

## Joining Climate Data

In the code block below, using the `left_join` function to combine the `cities`
dataset with the `koppen` metadata. Note that the key has a different name in
each of the two datasets.

```{r}
cities %>%
  left_join(koppen, by = c("koppen_code" = "code"))
```

Take a close look at the dataset you created in the last question. Scrolling
all the way to the final columns, you should see the name of the climate region
and the default color added into the dataset.

Something, however, has happened to the first variable in the combined
dataset. What is the (new) name of the first variable in the combined
output? **Answer**:

It turns out that both the `cities` dataset and the `koppen` dataset both
contain a variable named "name". In R, a dataset cannot contain two columns
with the same names. By default, `left_join` adds a suffix to distinguish
variables that came from the first dataset and those that came from the
second dataset. I generally find, the default suffix values to not be
ideal because they change both the names in the left table (the one that
contains the observations of interest) as well as the the new metadata
columns. Let's see how to change these suffix values.

The `left_join` function has an optional argument called `suffix`. You
can supply two string values to it to describe what suffix values are
placed on the first and second tables in the join. The default value is
`c(".x", ".y")`. I typically find something with the first entry empty
to be more pratical. So, for example: `c("", "_koppen")`. In the code
below, repeat the left join with this suffix option:

```{r}
cities %>%
  left_join(koppen, by = c("koppen_code" = "code"), suffix = c("", "_koppen"))
```

Verify that the variable names match what you expected to find in the new
dataset. The same suffix option can be used to modify the output for other
table joins.

Below, draw a plot with longitude on the x-axis and longitude on the y-axis.
Color the points based on the default Köppen codes using an identity color
scale:

```{r}
cities %>%
  left_join(koppen, by = c("koppen_code" = "code"), suffix = c("", "_koppen")) %>%
  ggplot() +
    geom_point(aes(x = lon, y = lat, color = color)) +
    scale_color_identity()
```

## Creating join table

So far we have worked only with data loaded into R through csv or Excel files.
It is also possible to directly create datasets within R code. This can be very
useful for quickly creating small metadata tables, particularly as a way of
cleaning and labelling data. In order to make a new dataset directly in R we
use the `tibble` function, describing each variable with names followed by
equals signs and the values contained within the function `c()`. For example,
here is a dataset with a column giving the names of the five continents in
our dataset next to the names of the continents in French:

```{r}
continent_names <- tibble(
  continent = c("Asia", "South America", "North America", "Africa", "Europe"),
  continent_fr = c("l'Asie", "l'Amérique du Sud", "l'Amérique du Nord", "l'Afrique", "l'Europe")
)

continent_names
```

In the code below, join the `cities` dataset with the `continent_fr` dataset.
Pipe the data into a plot with longitude on the x-axis and latitude on the
y-axis, coloring the points with the variable `c

```{r}
cities %>%
  left_join(continent_names, by = c("continent" = "continent")) %>%
  ggplot() +
    geom_point(aes(x = lon, y = lat, color = continent_fr))
```

The plot should now show the legend in French. In the code below, repeat
the procedure with a different language of your choice and recreate the
plot with the new labels.

```{r}

```

## Manual colors with a legend

There is one problem with the plot that we created to color the
cities by their Köppen codes. There's no legend for the plot. A
way to rectify this problem is to color the points using the
variable `name_koppen` and use the colors in the `koppen` metadata
table to describe a manual scale with `scale_color_manual`.
Specifically, we need:

   `scale_color_manual(values = koppen$color, labels = koppen$name)`.

Below, redo your plot with this color value and scale.

```{r}

```

The plot should like nice, but does requires a wide screen to see all of the defaults
given the long descriptions in the legend.
