---
title: "Project 03"
output:
  html_document:
    theme: cosmo
    highlight: zenburn
    css: "note-style.css"
---

## Overview

Each of the five prompts below provide a question prompt that you need to
address with one or more tables and/or plots. You only need to include text
where explicitly asked for, however please include each graphic or output in
its own code chunk. However you do need to properly label each plot (just a
title is okay, but axes should have labels and color palettes should be
chosen appropriately).

More detailed instructions are given on the Project 3 page linked to from the
course website.

**Project Team**:

## Getting Started

Before running this notebook, select "Session > Restart R and Clear Output" in
the menu above to start a new R session. This will clear any old data sets and
give us a blank slate to start with.

After starting a new session, run the following code chunk to load the
libraries and data that we will be working with today.

```{r, include=FALSE, message=FALSE}
library(tidyverse)
library(ggrepel)
library(smodels)
library(stringi)
library(lubridate)
library(sf)
library(units)
library(RcppRoll)

theme_set(theme_minimal())
options(dplyr.summarise.inform = FALSE)
options(width = 77L)
options(lubridate.week.start = 1)
Sys.setlocale(locale = "en_US.UTF-8")

sm_centroid <- function(data) {
  suppressWarnings({ z <- st_coordinates(st_centroid(data)) })
  return(tibble(lon = z[,1], lat = z[,2]))
}
```

### Load the Data

There are three datasets that you will use in this project. They
are similar to the datasets we had with the French data: a spatial
object (county), a dataset of demographic data, and a dataset of
daily Coronavirus records at the county level.

```{r, message = FALSE}
county <- read_sf(file.path("data", "us_counties.geojson"))
covid <- read_csv(file.path("data", "us_county_covid.csv"))
demog <- read_csv(file.path("data", "us_county_metadata.csv"))
```

The COVID-19 dataset has fewer columns than the one from France. It
has only cumulative case counts and reported deaths. Note that these
are only the counties with complete data from 01 April 2020.

```{r}
covid
```

The demographic data gives several points of information about each county.
Unless otherwise noted, the data comes from 2019.

```{r}
demog
```

Most of the variables should be self-explanatory. Unemployment rate is in
percentages (0-100), median household income in USD. February and August average
temperatures are in Celsius. The `physicians_per_pop` give the number of active
physicians per 100k residents according to the AAMC in 2018 at the state level.
Note that there is information for almost every county in the US, even if there
are no records in the COVID-19 dataset.

## Prompts

### 1. Spatial Extent

**Question** Show a spatial visualization (i.e., a map) of the infection rate
(cases per population) in the U.S. on 1 May 2020, 15 June 2020, and 1 October
for the "lower 48" states (no Hawaii, Alaska, or Puerto Rico). Also, separately
show the infection rate for Hawaii on 15 June 2020. Try to describe the patterns
in a few short sentences. Make sure to use appropriate projections and color
scales.

```{r}
county %>%
  inner_join(filter(covid, date == "2020-05-01"), by = c("fips", "state")) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  mutate(infect_rate = cases / population * 100000) %>%
  filter(!(state %in% c("HI", "AK", "PR"))) %>%
  st_transform(3083) %>%
  ggplot() +
    geom_sf(aes(fill = infect_rate), size = 0) +
    scale_fill_distiller(
      trans = "log2", palette = "Spectral", guide = "legend", n.breaks = 10,
      limits = c(2, 8192)
    ) +
    labs(fill = "Infection Rate\n (per 100k)") +
    theme_void()
```

```{r}
county %>%
  inner_join(filter(covid, date == "2020-06-15"), by = c("fips", "state")) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  mutate(infect_rate = cases / population * 100000) %>%
  filter(!(state %in% c("HI", "AK", "PR"))) %>%
  st_transform(3083) %>%
  ggplot() +
    geom_sf(aes(fill = infect_rate), size = 0) +
    scale_fill_distiller(
      trans = "log2", palette = "Spectral", guide = "legend", n.breaks = 10,
      limits = c(2, 8192)
    ) +
    labs(fill = "Infection Rate\n (per 100k)") +
    theme_void()
```

```{r}
county %>%
  inner_join(filter(covid, date == "2020-10-01"), by = c("fips", "state")) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  mutate(infect_rate = cases / population * 100000) %>%
  filter(!(state %in% c("HI", "AK", "PR"))) %>%
  st_transform(3083) %>%
  ggplot() +
    geom_sf(aes(fill = infect_rate), size = 0) +
    scale_fill_distiller(
      trans = "log2", palette = "Spectral", guide = "legend", n.breaks = 10,
      limits = c(2, 8192)
    ) +
    labs(fill = "Infection Rate\n (per 100k)") +
    theme_void()
```

```{r}
county %>%
  inner_join(filter(covid, date == "2020-06-15"), by = c("fips", "state")) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  mutate(infect_rate = cases / population * 100000) %>%
  filter(state == "HI") %>%
  st_transform(26961) %>%
  ggplot() +
    geom_sf(aes(fill = infect_rate), size = 0.7, color = "black") +
    scale_fill_distiller(
      palette = "Spectral", guide = "legend", n.breaks = 10
    ) +
    labs(fill = "Infection Rate\n (per 100k)") +
    coord_sf(xlim = c(0, 572762.8), ylim = c(8500, 400000)) +
    theme_void()

```

### 2. Political Party

**Question** How does the general political affiliation at the county level
relate to the observed case fatality rate (cases / deaths) and the overall
infection rate (cases / population)? Answer the question on a month-by-month
basis (i.e., compute the rates for each month separately, not cumulatively) and
plot these showing the change over time.

```{r}
party_data <- covid %>%
  filter(day(date) == 1) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  group_by(fips) %>%
  mutate(
    deaths_new = lead(deaths) - deaths,
    cases_new = lead(cases) - cases,
    party = if_else(per_gop_2016 > per_dem_2016, "R", "D")
  ) %>%
  filter(!is.na(cases_new), !is.na(deaths_new)) %>%
  group_by(date, party) %>%
  summarize(
    n = n(),
    inf_rate = sum(cases_new) / sum(population),
    case_fat_rate = sum(deaths_new) / sum(cases_new)
  )
```


```{r}
party_data %>%
  ggplot(aes(date, case_fat_rate)) +
    geom_line(aes(color = party)) +
    scale_color_manual(values = c("blue", "red"))
```

```{r}
party_data %>%
  ggplot(aes(date, inf_rate)) +
    geom_line(aes(color = party)) +
    scale_color_manual(values = c("blue", "red"))
```


### 3. Largest Counties

**Question** Visualize the number of new cases in the 8 largest counties over
the time range of the entire dataset for each day using a 7-day moving average.

```{r}
top_counties <- demog %>%
  arrange(desc(population)) %>%
  slice(1:8)

covid %>%
  semi_join(top_counties, by = c("fips", "state")) %>%
  group_by(fips) %>%
  mutate(cases_new = cases - lag(cases)) %>%
  mutate(cases_new_smooth = roll_meanr(cases_new, n = 7)) %>%
  filter(!is.na(cases_new_smooth)) %>%
  ggplot(aes(date, cases_new_smooth)) +
    geom_line(aes(color = county)) +
    scale_x_date(date_breaks = "month", date_labels = "%B") +
    theme_sm() +
    facet_wrap(~county)
```


### 4. Population Density

**Question** Compute the population density of each county. Group the counties
into 5 groups based on their population density and compute the overall fatality
rate (cases / deaths), infection rate (cases / population) and mortality rate
(deaths / cases) for each group on 1 October.

```{r}
county_density <- county %>%
  left_join(demog, by = c("fips", "state")) %>%
  mutate(area = as.numeric(set_units(st_area(geometry), "km^2"))) %>%
  mutate(density = population / area) %>%
  mutate(bucket = cut(log2(density + 1), breaks = 5, labels = FALSE)) %>%
  as_tibble()

covid %>%
  filter(date == "2020-10-01") %>%
  inner_join(county_density, by = c("fips", "state")) %>%
  group_by(bucket) %>%
  summarize(
    case_fatality_rate = sum(deaths) / sum(cases),
    infection_rate = sum(cases) / sum(population),
    total_mortality_rate = sum(deaths) / sum(population)
  )
```


### 5. Cases and Deaths Lag

**Question** At the county level, aggregated over each week, what's the "lag"
between deaths and cases? That is, if we look at the number of deaths in one
week in the dataset is it most closely correlated with the number of cases in
the week in question, one week before, two weeks before, three weeks before,
or more? As an optional challenge, try to plot the relationship without
resorting to manually copying the numbers (you might need a pivot function
here).

```{r}
covid %>%
  filter(wday(date) == 1) %>%
  group_by(fips, state) %>%
  mutate(cases_new = cases - lag(cases), deaths_new = deaths - lag(deaths)) %>%
  mutate(
    cases_new_0 = cases_new,
    cases_new_1 = lag(cases_new, n = 1),
    cases_new_2 = lag(cases_new, n = 2),
    cases_new_3 = lag(cases_new, n = 3),
    cases_new_4 = lag(cases_new, n = 4),
    cases_new_5 = lag(cases_new, n = 5),
    cases_new_6 = lag(cases_new, n = 6),
    cases_new_7 = lag(cases_new, n = 7)
  ) %>%
  ungroup() %>%
  summarise(
    sm_cor(deaths_new, cases_new_0),
    sm_cor(deaths_new, cases_new_1),
    sm_cor(deaths_new, cases_new_2),
    sm_cor(deaths_new, cases_new_3),
    sm_cor(deaths_new, cases_new_4),
    sm_cor(deaths_new, cases_new_5),
    sm_cor(deaths_new, cases_new_6),
    sm_cor(deaths_new, cases_new_7)
  ) %>%
  pivot_longer(cols = everything()) %>%
  mutate(week_lag = as.numeric(stri_extract(name, regex = "[0-9]"))) %>%
  ggplot(aes(week_lag, value)) +
    geom_line()
```

```{r}
covid_new <- covid %>%
  group_by(fips, state) %>%
  mutate(cases_new = cases - lag(cases), deaths_new = deaths - lag(deaths)) %>%
  mutate(
    cases_new = roll_meanr(cases_new, n = 7),
    deaths_new = roll_meanr(deaths_new, n = 7),
  ) %>%
  inner_join(demog, by = c("fips", "state")) %>%
  group_by(fips)

lag_data <- tibble(day_lag = seq(0, 60), cor = NA_real_)
for (j in seq_len(nrow(lag_data)))
{
  covid_new <- mutate(covid_new, cases_new_lag = lag(cases_new, n = j - 1))

  X <- as.matrix(select(ungroup(covid_new), deaths_new, cases_new_lag, population))
  X <- X[apply(!is.na(X), 1, all),]
  lag_data$cor[j] <- cov.wt(X[, 1:2], wt = X[, 3], cor = TRUE)$cor[1, 2]
}

lag_data %>%
  ggplot(aes(day_lag, cor)) +
    geom_point() +
    geom_line() +
    scale_x_continuous(breaks = seq(0, 60, by = 5), minor_breaks = NULL)
```
